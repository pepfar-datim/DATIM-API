---
title: "Securing-user-mechanism-access"
output: html_document
vignette: >
  %\VignetteIndexEntry{Securing-user-mechanism-access}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
```



## Who is this Vignette for?

If you are a shiny app developer deploying apps with PEPFAR's PDAP DataLake Team, you can use the following process and functions in [datimutils](https://github.com/pepfar-datim/datimutils) to make sure your users have appropriate mechnanism access. This process is relatively simple and requires standard usage of the `loginToDATIM` process. In order to understand who a user is, your code will need to check accessible data streams with the objective of classifying a user based on those streams. A developer can then classify their user and limit mechanism access as needed.

## Getting Data Streams

To access data steams and classify a user, developers can leverage the new `getMyStreams` wrapper to access the `getUserGroups` DATIM endpoint. You can pass your credentials to classify a user:

```{r get_streams_user_type, eval=T, echo = F}

# login 
loginToDATIM(
  config_path = "~/secrets/datim.json",
  base_url = "https://test.datim.org/",
  d2_session_name = "d2_default_session",
  d2_session_envir = parent.frame()
)

# get streams
streams <- getMyStreams()

# pass streams to user type classifier
print(
  paste("User type: ", getMyUserType(streams))
  )
```

## Accessing Mechanisms

Once a user type is classified, developers can start to enforce limitations on data access. Mechanisms can be pulled and filtered on the desired columns; here for example we extract only mech_code and name:  

```{r get_mechs, eval=T}

# pull all mechanisms
user_mechs <- listMyMechs()
DT::datatable(
  head(user_mechs) %>% 
    select(mech_code, name)
  )
```

## A Shiny App Example

The above functions are meant to be used in shiny apps and so developers will not be passing username and passwords hard coded into functions as these are great security risks. Developers can extract the username and password inputs in a manner similar to BAO's `datapacker-app`. Developers can access an example app with a similar structure based on the data they will be exposing: [usg only](https://github.com/flopez-bao/shinyapps-datimutils-security-example-usgonly) or [partners](https://github.com/flopez-bao/shinyapps-datimutils-security-example-partners). Clone the github repo, make sure you have all the necessary packages and then set up a `config` file for `datimutils` to consume. Upon launching the app you should see the DATIM screen. 

For folks making apps with data meant for agencies aka USG folks we can outright deny access to the app by providing an immediate signout:

```{r usg, echo=t, eval = F}
...
tryCatch({
      datimutils::loginToDATIM(base_url = Sys.getenv("BASE_URL"),
                               username = input$user_name,
                               password = input$password,
                               d2_session_envir = parent.env(environment())
      )
      
      # DISALLOW USER ACCESS TO THE APP-----
      
      # access data streams
      d <- getMyStreams()
      # classify a user
      d <- getMyUserType(d)
      
      #if a user is not to be allowed deny them entry
      if (!d %in% USG_USERS) {
        
        # alert the user they cannot access the app
        sendSweetAlert(
          session,
          title = "Login failed",
          text = "You are not authorized to use this application",
          type = "error"
        )
        
        # log them out
        Sys.sleep(3)
        flog.info(paste0("User ", user_input$d2_session$me$userCredentials$username, " logged out."))
        user_input$authenticated  <-  FALSE
        user_input$user_name <- ""
        user_input$authorized  <-  FALSE
        user_input$d2_session  <-  NULL
        d2_default_session <- NULL
        gc()
        session$reload()
      
      }
...
```

For folks targeting data that is accessible to partners they must filter information for partners while still providing a full view of the data that is accessible to agencies. In the repo provided above we see this:

```{r partners, echo=t, eval = F}
...
#show mechs by mechs id
  observeEvent(input$mech_id_button, {
    
    # get streams and user type information
    d <- getMyStreams()
    d <- getMyUserType(d$stream)
    
    # test if a user is an agency user
    if(d %in% USG_USERS) {
      
      my_cat_ops <- listMyMechs()
      
      output$table <- renderDataTable(my_cat_ops,
                                      options = list(
                                        pageLength = 10,
                                        initComplete = I("function(settings, json) {alert('Done.');}")
                                      )
      )
    # test if a user is a partner
    } else if (d %in% PARTNER_USERS) {
      
      my_cat_ops <- listMyMechs()
      my_cat_ops_f <- merge(my_cat_ops, sample_data, by = "mech_code")
      
      output$table <- renderDataTable(my_cat_ops_f,
                                      options = list(
                                        pageLength = 10,
                                        initComplete = I("function(settings, json) {alert('Done.');}")
                                      )
      )
      
      
    } else {
      access_denied <- paste("You are not allowed to see this information.")
      output$message <- renderPrint({ access_denied })  
      
    }
    
  })

...
```

Developers can reference the server code in the github repo to see how the action buttons tie to the functions.


